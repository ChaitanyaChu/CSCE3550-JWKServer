#Chaitanya Chunduri
#cc1278
#11498621
#Project 1-Implementing a JWKS Server

# Import necessary modules and libraries
from http.server import HTTPServer, BaseHTTPRequestHandler
from cryptography.hazmat.primitives.asymmetric import rsa
from cryptography.hazmat.primitives import serialization
from datetime import datetime, timedelta, timezone
from jwt.utils import base64url_encode, bytes_from_int
import json
import uuid
import jwt

# Define a custom request handler class inheriting from BaseHTTPRequestHandler
class CustomRequestHandler(BaseHTTPRequestHandler):
    # Storage for JSON Web Key Set (JWKS)
    jwks_data = {"keys": []}

    # HTTP methods handling
    def do_PUT(self):
        # Respond with Method Not Allowed status code for unsupported HTTP method
        self.send_response(405)
        self.end_headers()

    def do_DELETE(self):
        # Respond with Method Not Allowed status code for unsupported HTTP method
        self.send_response(405)
        self.end_headers()

    def do_PATCH(self):
        # Respond with Method Not Allowed status code for unsupported HTTP method
        self.send_response(405)
        self.end_headers()

    def do_HEAD(self):
        # Respond with Method Not Allowed status code for unsupported HTTP method
        self.send_response(405)
        self.end_headers()

    # Handle GET requests
    def do_GET(self):
        # Check if the request is for JWKS endpoint
        if self.path == "/.well-known/jwks.json":
            # Respond with JWKS when requested
            self.send_response(200)
            self.end_headers()
            self.wfile.write(json.dumps(self.jwks_data, indent=1).encode("UTF-8"))
            return
        else:
            # Respond with Method Not Allowed status code for other paths
            self.send_response(405)
            self.end_headers()
            return

    # Handle POST requests
    def do_POST(self):
        # Check if the request is for authentication
        if self.path in ["/auth", "/auth?expired=true", "/auth?expired=false"]:
            # Determine if the token should be expired
            expired = self.path == "/auth?expired=true"
            # Respond with OK status code
            self.send_response(200)
            self.end_headers()
            # Generate RSA key pair
            private_key = self.generate_key_pair()
            # Serialize private key
            private_key_bytes = private_key.private_bytes(
                encoding=serialization.Encoding.PEM,
                format=serialization.PrivateFormat.PKCS8,
                encryption_algorithm=serialization.NoEncryption()
            )
            # Extract public key
            public_key = private_key.public_key()
            # Generate unique key ID
            key_id = str(uuid.uuid4())
            # Set expiry time
            expiry_time = (datetime.now(tz=timezone.utc) - timedelta(seconds=3600)) if expired else (datetime.now(tz=timezone.utc) + timedelta(seconds=3600))
            # Generate JWT token
            jwt_token = jwt.encode({"exp": expiry_time}, private_key_bytes, algorithm="RS256", headers={"kid": key_id})
            self.wfile.write(bytes(jwt_token, "UTF-8"))
            # Construct and append JWK if token not expired
            jwk = {
                "kty": "RSA",
                "kid": key_id,
                "alg": "RS256",
                "n": base64url_encode(bytes_from_int(public_key.public_numbers().n)).decode("UTF-8"),
                "e": base64url_encode(bytes_from_int(public_key.public_numbers().e)).decode("UTF-8"),
                "use": "sig",
            }
            if expiry_time > datetime.now(tz=timezone.utc):
                self.jwks_data["keys"].append(jwk)
            return
        else:
            # Respond with Method Not Allowed status code for other paths
            self.send_response(405)
            self.end_headers()
            return

    # Generate RSA key pair
    def generate_key_pair(self):
        private_key = rsa.generate_private_key(public_exponent=65537, key_size=2048)
        return private_key

# Create an HTTP server on localhost and port 8080
http_server = HTTPServer(("", 8080), CustomRequestHandler)
print("Server is running on port 8080")
try:
    http_server.serve_forever()  # Run the server indefinitely
except KeyboardInterrupt:
    pass
http_server.server_close()  # Close the server on keyboard interrupt
